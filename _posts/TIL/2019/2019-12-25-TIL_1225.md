---
layout: post
title: "TIL - 1225"
date: 2019-12-25 00:00:00
img:
categories:
- TIL
tags: [TIL, OS]
---

## 9장 - 세그멘테이션, 가상메모리

## 4.6 세그멘테이션

- 프로세스를 논리적 내용(세그멘트)로 잘라서 메모리에 배치
- 프로세스는 세그멘트의 집합 ⇒ 세그멘트의 크니는 일반적으로 같지 않음
- 세그멘트를 메모리에 할당
- **CPU 는 프로세스가 연속된 메모리 공간에 위치한다고 착각 ← MMU 는 세그멘트 테이블**

### 어떻게?

![9/Untitled.png](/assets/post_img/191225-1.png)
- limit 과 base 가 바뀐듯
- 논리주소: cpu가 내는 주소 segment (s) + 변위 (d)
- 주소변환 (논리 → 물리)
    - 세그멘트 번호(s): 세그멘트 테이블 인덱스값
    - s 에 해당되는 테이블 내용으로 시작 위치 및 한계값(limit) 파악 → 한계 넘으면 segment violation 예외 상황 처리
    - 물리주소 = base[s] + d
        - 논리주소 (2, 100) = 4300 + 100 = 4400
        - 논리주소(1, 500) = 6300 + 500 = 6800 → limit 을 넘어가기 때문에 안됨
- 보호
    - 페이지 vs 세그멘트 → 세그멘트가 좀더 좋음
        - 페이지의 경우 일정크기로 나누기 때문에 data + code  이런식으로 섞여 있는 경우가 있음
        - 세그먼트는 섞일 이유가 없기 때문에 r/w/x 에 따라서 가능하게 나눌 수 있음
- 공유
    - 페이지 vs 세그멘트 → 세그멘트가 좀더 좋음

### 내부 단편화 vs 외부 단편화

1. 내부단편화
    - 프로세스 크기가 페이지 크기의 배수가 아니라면 마지막 페이지는 한 프레임을 다 채울 수 없음
    - 남은 공간 ⇒ 메모리 낭비
    - 내부단편화는 메모리가 크지 않기 때문에 큰 문제는 아님
2. 외부단편화
    - 중간중간에 생긴 사용하지 않는 메모리가 많이 존재해서 총 메모리 공간은 충분하나 실제로 할당이 불가능
    - 페이징으로 외부 단편화를 해결
    - 세그멘트 크기는 고정이 아니라 가변적이기 때문에 페이징 사용
        - 세그멘트를 사용하는 경우 동적 메모리 할당해야하고 이는 외부단편화로 이어짐

### Paged segmentation

- 세그멘테이션 + 페이징
- 세그멘테이션 ⇒ 보호와 공유면에서 효과적
- 페이징 ⇒ 외부 단편화 문제를 해결
- code, data, stack 이런식으로 세그멘트 단위로 나눈뒤 code 안에 프로세스들을 페이징으로 나눔

## 5장 가상 메모리

- 물리 메모리 크기 한계를 극복
- 프로세스 이미지를 모두 메모리에 올리지 않음 → 현재 실행에 필요한 부분만 메모리에 올림